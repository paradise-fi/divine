// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * (c) 2010-2019 Petr Ročkai <code@fixp.eu>
 * (c) 2012-2014 Jiří Weiser <xweiser1@fi.muni.cz>
 * (c) 2013-2014 Vladimír Štill <xstill@fi.muni.cz>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#pragma once

#include <brick-hash>
#include <brick-ptr>
#include <brick-shmem>
#include <brick-bitlevel>
#include <brick-assert>
#include <brick-trace>
#include <brick-types>

#include <type_traits>
#include <set>

/*
 * Various fast hash table implementations, including a concurrent-access hash
 * table. See also ...
 */

namespace brq
{
    template< typename T >
    struct hash_adaptor;

    struct hash_set_stats { size_t used = 0, capacity = 0; };
}

namespace brq::impl
{
    template< typename X >
    auto hash( const X &v ) -> decltype( brq::hash( v ) )
    {
        return brq::hash( v );
    }

    template< typename X >
    auto hash( const X &t ) -> decltype( t.hash() )
    {
        return t.hash();
    }

    static inline hash64_t highbits( hash64_t orig, int bits )
    {
        // use a different part of the hash than what we use for indexing
        return orig >> ( sizeof( hash64_t ) * 8 - bits );
    }

    /*
     * Tables are represented as vectors of cells.
     */

    template< typename T >
    struct cell_base
    {
        using value_type = T;
        using reference = const T &;
        using pointer = const T *;
        static constexpr bool can_tombstone() { return false; }
        bool tombstone() const { return false; }
    };

    template< typename T >
    struct fast_cell : cell_base< T >
    {
        T _value = T();
        hash64_t _hash = 0; // TODO: re-use when rehashing

        bool match( hash64_t h ) const { return _hash == h; }
        bool invalid() const { return false; }
        bool empty() const { return !_hash; }
        const T *value() const { return &_value; }
        T &fetch() { return _value; }
        T copy() { return _value; }

        void store( const T &t, hash64_t h ) { _hash = h; _value = t; }
        bool try_store( const T &t, hash64_t h ) { store( t, h ); return true; }
        fast_cell invalidate() { return *this; }
    };

    template< typename T >
    struct compact_cell : cell_base< T >
    {
        T _value = T();

        bool match( hash64_t ) const { return true; }
        bool empty() const { return !_value; } /* meh */
        bool invalid() const { return false; }
        const T *value() const { return &_value; }
        T &fetch() { return _value; }
        T copy() { return _value; }

        void store( T bn, hash64_t ) { _value = bn; }
        bool try_store( T v, hash64_t h ) { store( v, h ); return true; }
        compact_cell invalidate() { return *this; }
    };

    template< typename T >
    struct locked_cell : cell_base< T >
    {
        /* 2 least-significant bits are special */
        std::atomic< hash32_t > _hashlock;
        T _value;

        bool empty() const { return _hashlock == 0; }
        bool invalid() const { return _hashlock == 3; }
        bool tombstone() const { return _hashlock == 2; }

        const T *value() const { return &_value; }
        T &fetch() { return _value; }
        T copy() { return _value; }

        // wait for another write; returns false if cell was invalidated
        bool wait() const
        {
            while ( _hashlock & 1 )
                if ( invalid() )
                    return false;
            return !tombstone();
        }

        bool match( hash32_t hash ) const
        {
            hash |= 1;
            if ( ( ( hash << 2 ) | 1 ) != ( _hashlock | 1 ) )
                return false;
            if ( wait() )
                return true;
            else
                return false;
        }

        static constexpr bool can_tombstone() { return true; }

        /* returns old cell value */
        locked_cell invalidate()
        {
            // wait for write to end
            hash32_t prev = 0;
            while ( !_hashlock.compare_exchange_weak( prev, 3 ) )
            {
                if ( prev == 3 ) /* already invalid */
                    return locked_cell( prev, _value );
                if ( prev != 2 )
                    prev &= ~3; // clean flags
            }
            return locked_cell( prev, _value );
        }

        bool bury()
        {
            hash32_t hl = _hashlock.load();
            if ( invalid() )
                return false;
            return _hashlock.compare_exchange_strong( hl, 2 );
        }

        bool try_store( const T &v, hash32_t hash )
        {
            hash |= 1;
            hash32_t chl = 0;
            if ( _hashlock.compare_exchange_strong( chl, (hash << 2) | 1 ) )
            {
                _value = v;
                _hashlock.exchange( hash << 2 ); /* unlock */
                return true;
            }
            return false;
        }

        void store( const T &v, hash32_t hash )
        {
            _hashlock = hash << 2;
            _value = v;
        }

        locked_cell() : _hashlock( 0 ), _value() {}

    private:
        locked_cell( hash32_t h, const T &val ) : _hashlock( h ), _value( val ) {}
    };

    template< typename T, typename = void >
    struct tagged
    {
        using Type = tagged< T >;
        struct Align { T a; uint16_t b; };
        using Tag = brick::bitlevel::bitvec< 8 * ( sizeof( Align ) - sizeof( T ) ) >;
        struct Check { T a; Tag b; };
        static_assert( sizeof( Align ) == sizeof( Check ) );
        static_assert( sizeof( Check ) == sizeof( T ) + sizeof( Tag ) );

        T _value;
        Tag _tag;

        static const int tag_bits = sizeof( Tag ) * 8;

        T &value() { return _value; }
        const T &value() const { return _value; }
        void tag( Tag v ) { _tag = v; }
        Tag tag() { return _tag; }
        tagged() noexcept : _value(), _tag( 0 ) {}
        explicit tagged( const T &v ) : _value( v ), _tag( 0 ) {}
        operator T() const { return _value; }

        friend std::ostream &operator<<( std::ostream &o, const tagged< T > &v )
        {
            return o << "[" << v._value << " " << uint64_t( v._tag ) << "]";
        }

        static T fetch( const std::atomic< Type > &t ) { return t.load().value(); }
        static T fetch( const Type &t ) { return t; }
    };

    template< typename T >
    struct tagged< T, typename std::enable_if< (T::tag_bits > 0) >::type > : T
    {
        using Type = T;
        static T fetch( const std::atomic< T > &t ) { return t.load(); }
        static T fetch( const T &t ) { return t; }
    };

    template< typename T >
    struct alignas( std::min( 16ul, sizeof( tagged< T > ) ) ) atomic_cell : cell_base< T >
    {
        using tagged = tagged< T >;
        using bare_value = typename tagged::Type;
        using atomic_value = std::atomic< bare_value >;
        using pointer = const atomic_value *;
        using reference = const atomic_value &;

        atomic_value _value;

        static_assert( atomic_value::is_always_lock_free );
        static_assert( bare_value::tag_bits >= 2, "T has at least a two-bit tagspace" );

        static constexpr bool can_tombstone() { return true; }

        uint32_t status() const { return _value.load().tag() & 3u; }
        static hash64_t hashbits( hash64_t in ) { return highbits( in, bare_value::tag_bits - 2 ) << 2; }

        bool empty() const { return status() == 0; }
        bool invalid() const { return status() == 1; }
        bool tombstone() const { return status() == 2; }

        pointer value() const { return &_value; }
        T fetch() const { return tagged::fetch( _value ); }
        T copy() const { bare_value v = _value; v.tag( 0 ); return tagged::fetch( v ); }
        bool wait() { return !invalid(); }
        bool match( hash64_t hash ) const { return _value.load().tag() == ( hashbits( hash ) | 3 ); }
        bool tombstone( hash64_t hash ) const { return _value.load().tag() == ( hashbits( hash ) | 2 ); }

        /* returns old cell value */
        atomic_cell invalidate()
        {
            bare_value expect = _value, update = _value;
            update.tag( 1 );
            while ( !_value.compare_exchange_weak( expect, update ) )
            {
                update = expect;
                update.tag( 1 );
            }
            return atomic_cell( expect );
        }

        bool bury()
        {
            bare_value expect = _value, update = expect;
            if ( invalid() )
                return false;
            update.tag( ( update.tag() & ~decltype( update.tag() )( 3 ) ) | 2 );
            return _value.compare_exchange_strong( expect, update );
        }

        bool revive()
        {
            bare_value expect = _value, update = expect;
            if ( invalid() )
                return false;
            update.tag( update.tag() | 3u );
            return _value.compare_exchange_strong( expect, update );
        }

        void store( T bn, hash64_t hash )
        {
            bare_value next( bn );
            next.tag( hashbits( hash ) | 3 );
            _value.store( next );
        }

        bool try_store( T b, hash64_t hash )
        {
            bare_value zero, tomb;
            bare_value next( b );
            next.tag( hashbits( hash ) | 3 );
            tomb.tag( 2 );
            auto rv = _value.compare_exchange_strong( zero, next );
            if ( !rv )
                rv = _value.compare_exchange_strong( tomb, next );
            return rv;
        }

        atomic_cell() : _value() {}
        atomic_cell( const atomic_cell & ) : _value() {}
        explicit atomic_cell( bare_value val ) : _value( val ) {}
    };

    template< typename T >
    using default_cell = std::conditional_t< ( sizeof( T ) < 16 ), compact_cell< T >, fast_cell< T > >;

    template< typename T >
    using concurrent_cell =
        std::conditional_t< std::atomic< typename tagged< T >::Type >::is_always_lock_free,
                            atomic_cell< T >, locked_cell< T > >;

    template< typename Cell_ >
    struct hash_set_base
    {
        using Cell = Cell_;
        using value_type = typename Cell::value_type;
        using pointer = typename Cell::pointer;
        using reference = typename Cell::reference;

        struct iterator
        {
            pointer _value;
            bool _new;

            iterator( pointer v = nullptr, bool n = false )
                : _value( v ), _new( n )
            {}
            pointer operator->() const { return _value; }
            reference operator*() const { return *_value; }
            value_type copy() const { return **this; }
            bool valid() const { return _value; }
            bool isnew() const { return _new; }
        };

        iterator end() { return iterator(); }
    };

    template< typename Cell, unsigned max_chain, unsigned Segment, bool concurrent >
    struct hash_table : brq::refcount_base< uint16_t, true >
    {
        brq::refcount_ptr< hash_table, true > next;
        std::atomic< size_t > _size;
        std::atomic< ssize_t > to_rehash;
        Cell data[];

        using value_type = typename Cell::value_type;

        enum LookupTag { Found, Empty, Invalid };
        using Lookup = std::pair< typename Cell::pointer, LookupTag >;
        enum InsertMode { Rehash, Insert };

        template< typename stream >
        friend auto operator<<( stream &o, LookupTag t ) -> decltype( o << "" )
        {
            switch ( t )
            {
                case Found: return o << "found";
                case Empty: return o << "empty";
                case Invalid: return o << "invalid";
                default: return o << int( t );
            }
        }

        static void *operator new( size_t objsize, size_t cellcount )
        {
            auto rv = malloc( objsize + cellcount * sizeof( Cell ) );
            if ( !rv )
                throw std::bad_alloc();
            return rv;
        }

        hash_table( size_t size, ssize_t rehash )
            : next( nullptr ), _size( size ), to_rehash( rehash )
        {
            std::uninitialized_default_construct( data, data + size );
        }

        size_t size() { return _size.load( std::memory_order_relaxed ); }
        size_t segment_size() { return Segment; }
        size_t segment_count() { return size() / segment_size(); }
        Cell *segment_end( int id ) { return segment_begin( id ) + segment_size(); }
        Cell *segment_begin( int id )
        {
            ASSERT_LT( id, segment_count() );
            return data + segment_size() * id;
        }

        static constexpr const size_t cluster_bytes = 32;
        static constexpr const size_t cluster_size = std::max( 1ul, cluster_bytes / sizeof( Cell ) );

        static size_t index( hash64_t h, unsigned i, size_t mask )
        {
            const unsigned Q = 1, R = 1;
            size_t j = i % cluster_size; /* index within cluster */
            i = i / cluster_size;        /* index to the start of the cluster */
            size_t hop = (2 * Q + 1) * i + 2 * R * i * i;
            return ( h + j + hop * cluster_size ) & mask;
        }

        template< typename X, typename A > [[gnu::always_inline]]
        Lookup insert( const X &x, hash64_t h, const A &adaptor, InsertMode mode = Insert )
        {
            const size_t mask = size() - 1;
            const unsigned max = mode == Rehash ? 3 * max_chain / 4 : max_chain;

            ASSERT_EQ( mask & size(), 0 );
            ASSERT_EQ( mask | size(), mask + size() );

            Cell *tomb = nullptr;

            for ( unsigned i = 0; i < max; ++i )
            {
                Cell &cell = data[ index( h, i, mask ) ];

                if ( cell.invalid() )
                    return { nullptr, Invalid };

                if ( cell.empty() )
                {
                    if constexpr ( !concurrent )
                        if ( tomb && tomb->try_store( x, h ) )
                            return { tomb->value(), Empty };

                    if ( cell.try_store( x, h ) )
                        return { cell.value(), Empty };
                }

                if constexpr ( !concurrent )
                    if ( !tomb && cell.tombstone() )
                        tomb = &cell;

                if ( cell.match( h ) )
                    if ( auto v = adaptor.match( cell, x, h ) )
                        return { v, Found };
            }

            TRACE( "insert failed after", max, "collisions on", x, "hash", std::hex, h );
            return { nullptr, Empty };
        }

        template< typename X, typename F >
        auto find_generic( const X &x, hash64_t h, F match )
            -> std::pair< decltype( match( std::declval< Cell & >(), x, h ) ), LookupTag >
        {
            const size_t mask = size() - 1;

            for ( size_t i = 0; i < max_chain; ++i )
            {
                Cell &cell = data[ index( h, i, mask ) ];
                if ( cell.invalid() )
                    return { nullptr, Invalid };
                if ( cell.empty() )
                    return { nullptr, Empty };
                if ( cell.match( h ) )
                    if ( auto v = match( cell, x, h ) )
                        return { v, Found };
            }
            return { nullptr, Empty };
        }

        template< typename X, typename A >
        Lookup find( const X &x, hash64_t h, const A &adaptor )
        {
            auto m = [&]( Cell &c, const X &x, hash64_t h ) { return adaptor.match( c, x, h ); };
            return find_generic( x, h, m );
        }
    };

    template< size_t I, size_t... Next >
    struct grow
    {
        static constexpr const size_t Initial = I;

        template< size_t >
        static size_t next( size_t s ) { return 2 * s; }

        template< size_t X, size_t Y, size_t... S >
        static size_t next( size_t s )
        {
            if ( s == X )
                return Y;
            else
                return next< Y, S... >( s );
        }

        static size_t next_size( size_t s )
        {
            return next< I, Next... >( s );
        }
    };

    using quick = grow< 0x100, 0x1000, 0x10000, 0x80000, 0x100000, 0x400000 >;
    using slow  = grow< 0x10 >;

    template< typename cell, bool concurrent, typename grow_t = impl::quick, int max_chain = 24 >
    struct hash_set : hash_set_base< cell >
    {
        using Base = hash_set_base< cell >;
        using Self = hash_set< cell, concurrent, grow_t, max_chain >;

        using typename Base::value_type;
        using typename Base::iterator;
        using table = impl::hash_table< cell, max_chain, grow_t::Initial, concurrent >;

        brq::refcount_ptr< table > _table;

        size_t capacity()
        {
            while ( await_update() );
            return _table->size();
        }

        hash_set_stats stats()
        {
            while ( await_update() );

            hash_set_stats st;
            st.capacity = _table->size();
            for ( size_t i = 0; i < st.capacity; ++i )
                if ( !_table->data[ i ].empty() )
                    st.used ++;
            return st;
        }

        template< typename A >
        bool check_outdated( const A &adaptor )
        {
            if constexpr ( !concurrent )
                return false;

            auto next = _table->next;
            if ( !next )
                return false;

            while ( rehash_segment( adaptor, *_table, *next ) );

            await_update();
            check_outdated( adaptor );

            return true;
        }

        bool await_update()
        {
            if ( auto next = _table->next )
            {
                _table = next;
                while ( _table->to_rehash.load() < 0 );
                return true;
            }
            return false;
        }

        template< typename X, typename A = hash_adaptor< value_type > >
        iterator insert( const X &x, const A &adaptor = A() )
        {
            return insert( x, adaptor.hash( x ), adaptor );
        }

        template< typename X, typename A = hash_adaptor< value_type > >
        iterator insert( const X &x, hash64_t h, const A &adaptor = A(), bool wasnew = false )
        {
            auto [ value, outcome ] = _table->insert( x, h, adaptor, table::Insert );

            if ( !value && outcome == table::Empty )
                return grow( adaptor ), insert( x, h, adaptor );

            if ( check_outdated( adaptor ) )
            {
                TRACE( _table, "insert", x, "→ outdated, retrying; outcome was", outcome );
                return insert( x, h, adaptor, outcome == table::Empty );
            }

            ASSERT_NEQ( outcome, table::Invalid );
            TRACE( _table, "insert", x, "hash", std::hex, h, "→",
                   wasnew || outcome == table::Empty ? "new" : "old" );
            return iterator( value, wasnew || outcome == table::Empty );
        }

        template< typename X, typename A = hash_adaptor< value_type > >
        iterator find( const X &x, const A &adaptor = A() )
        {
            return find( x, adaptor.hash( x ), adaptor );
        }

        template< typename X, typename A = hash_adaptor< value_type > >
        iterator find( const X &x, hash64_t h, const A &adaptor = A() )
        {
            auto [ value, outcome ] = _table->find( x, h, adaptor );
            if ( check_outdated( adaptor ) )
                return find( x, h, adaptor );
            else
                return iterator( value );
        }

        template< typename X, typename A = hash_adaptor< value_type > >
        bool erase( const X &x, const A &adaptor = A() )
        {
            return erase( x, adaptor.hash( x ), adaptor );
        }

        template< typename X, typename A = hash_adaptor< value_type > >
        bool erase( const X &x, hash64_t h, const A &adaptor = A() )
        {
            static_assert( cell::can_tombstone() );

            bool buried = false;
            auto match_erase = [&]( cell &c, const X &x, hash64_t )
            {
                switch ( adaptor.erase( c, x ) )
                {
                    case A::Bury: buried = c.bury(); return true;
                    case A::Done: buried = true; return true;
                    case A::Mismatch: return false;
                }
            };

            auto [ c, outcome ]  = _table->find_generic( x, h, match_erase );

            if ( outcome == table::Found && !buried )
                outcome = table::Invalid;

            if ( check_outdated( adaptor ) )
            {
                TRACE( _table, "erase outdated, retry?", outcome == table::Found ? "no" : "yes" );
                return outcome == table::Found || erase( x, h, adaptor );
            }
            else
            {
                TRACE( _table, "erase", x, "outcome", outcome );
                ASSERT_NEQ( outcome, table::Invalid );
                return outcome == table::Found;
            }
        }

        template< typename T, typename A = hash_adaptor< value_type > >
        int count( const T &x, const A &adaptor = A() ) { return find( x, adaptor ).valid() ? 1 : 0; }

        static std::pair< ssize_t, bool > atomic_add_if_nonzero( std::atomic< ssize_t > &v, int off )
        {
            ssize_t current = v.load(), next = current + off;
            if ( current )
                while ( !v.compare_exchange_weak( current, next ) && current )
                    next = current + off;

            if ( current )
                return { next, true };
            else
                return { 0, false };
        }

        template< typename A >
        bool rehash_segment( const A &adaptor, table &from, table &to )
        {
            auto [ id, success ] = atomic_add_if_nonzero( from.to_rehash, -1 );
            if ( !success )
                return false;

            TRACE( _table, "rehash segment", id, "from", &from, "to", &to );
            for ( auto c = from.segment_begin( id ); c != from.segment_end( id ); ++ c )
            {
                cell insert = c->invalidate();

                if ( insert.empty() || insert.invalid() )
                    continue;

                adaptor.invalidate( insert );

                if ( insert.tombstone() )
                    continue;

                auto value = insert.fetch();
                hash64_t hash = adaptor.hash( value );
                auto [ result, outcome ] = to.insert( value, hash, adaptor, table::Rehash );
                ASSERT_EQ( outcome, table::Empty );

                if ( !result )
                {
                    string_builder err;
                    err << "hash table " << _table << " failed to rehash at size " << _table->size();
                    to.to_rehash.store( 0 ); /* prevent stalls and deadlocks */
                    throw std::runtime_error( err.buffer() );
                }
            }

            TRACE( _table, "rehash", id, "done" );
            ++ to.to_rehash;
            return id > 0;
        }

        auto make_table( size_t size, ssize_t rehash )
        {
            return brq::refcount_ptr< table >( new ( size ) table( size, rehash ) );
        }

        template< typename A >
        void grow( const A &adaptor )
        {
            auto next = make_table( grow_t::next_size( _table->size() ), -_table->segment_count() - 1 );
            refcount_ptr< table > expect;

            TRACE( _table, "grow from", _table->size(), "to", grow_t::next_size( _table->size() ) );
            if ( _table->next.compare_exchange_strong( expect, next ) )
            {
                while ( rehash_segment( adaptor, *_table, *next ) );
                ASSERT_EQ( _table->to_rehash.load(), 0 );
                _table = next;
                while ( _table->to_rehash.load() != -1 );
                _table->to_rehash = _table->segment_count();
            }
            else
            {
                next.reset();
                check_outdated( adaptor );
                return;
            }
            TRACE( _table, "growth done" );
        }

        hash_set()
        {
            _table = make_table( grow_t::Initial, 0 );
            _table->to_rehash = _table->segment_count();
        }

        template< typename T >
        hash_set( const std::enable_if_t< std::is_same_v< T, Self > && !concurrent, hash_set > &o )
        {
            _table = make_table( o.capacity(), 0 );
            _table->to_rehash = _table->segment_count();
            /* TODO avoid the default-construct + overwrite here */
            std::copy( o._table->data, o._table->data + capacity(), _table->data );
        }

        cell &cell_at( size_t index ) { return _table->data[ index ]; }
        value_type valueAt( size_t idx ) { return cell_at( idx ).fetch(); }
        bool valid( size_t idx ) { return !cell_at( idx ).empty(); }
    };

}

namespace brq
{
    template< typename T >
    struct hash_adaptor
    {
        using value_type = T;
        using Payload = std::pair< T, hash64_t >;
        enum Erase { Bury, Done, Mismatch };

        template< typename X >
        hash64_t hash( const X &x ) const
        {
            return impl::hash( value_type( x ) );
        }

        template< typename cell, typename X >
        typename cell::pointer match( cell &c, const X &t, hash64_t ) const
        {
            return c.fetch() == t ? c.value() : nullptr;
        }

        template< typename cell, typename X >
        Erase erase( cell &c, const X &t ) const
        {
            return c.fetch() == t ? Bury : Mismatch;
        }

        template< typename cell >
        void invalidate( const cell & ) const {}
    };

    template< typename T, typename grow = impl::quick, int max_chain = 24 >
    using hash_set = impl::hash_set< impl::default_cell< T >, false, grow, max_chain >;

    template< typename T, typename grow = impl::quick, int max_chain = 24 >
    using concurrent_hash_set = impl::hash_set< impl::concurrent_cell< T >, true, grow, max_chain >;

}

namespace brq_t
{

#ifdef __divine__
    static constexpr int size = 4;
#else
    static constexpr int size = 32 * 1024;
#endif

    struct big
    {
        int v;
        std::array< int, 16 > padding;
        big( int v = 0 ) : v( v ) {}
        brq::hash64_t hash() const { return brq::hash( v ); }
        bool operator==( const big &o ) const { return v == o.v; }
        bool operator==( int o ) const { return v == o; }
        operator int() const { return v; }
    };

    template< template< typename, typename, int > class HS, typename V = int >
    struct sequential
    {
        using hashset = HS< V, brq::impl::quick, 24 >;

        TEST(insert_basic)
        {
            hashset set;

            ASSERT( !set.count( 1 ) );
            ASSERT( set.insert( 1 ).isnew() );
            ASSERT( set.count( 1 ) );

            unsigned count = 0;
            for ( unsigned i = 0; i != set.capacity(); ++i )
                if ( set.valueAt( i ) )
                    ++count;

            ASSERT_EQ( count, 1u );
        }

        TEST(stress) {
            hashset set;

            for ( int i = 1; i < size; ++i ) {
                set.insert( i );
                ASSERT( set.count( i ) );
            }
            for ( int i = 1; i < size; ++i ) {
                ASSERT( set.count( i ) );
            }
        }

        TEST(erase_basic)
        {
            if constexpr ( hashset::Cell::can_tombstone() )
            {
                hashset set;

                ASSERT( !set.count( 1 ) );
                ASSERT( set.insert( 1 ).isnew() );
                ASSERT( set.count( 1 ) );
                ASSERT( set.erase( 1 ) );
                ASSERT( !set.count( 1 ) );
                ASSERT( set.insert( 1 ).isnew() );
                ASSERT( set.count( 1 ) );
            }
        }

        TEST(erase_many)
        {
            if constexpr ( hashset::Cell::can_tombstone() )
            {
                hashset set;

                for ( int i = 1; i < size; ++i )
                {
                    set.insert( i );
                    ASSERT( set.count( i ) );
                    if ( i % 2 == 0 )
                    {
                        set.erase( i );
                        ASSERT( !set.count( i ) );
                    }
                }

                for ( int i = 1; i < size; ++i )
                    ASSERT_EQ( set.count( i ), i % 2 );
            }
        }

        TEST(set) {
            hashset set;

            for ( int i = 1; i < size; ++i ) {
                ASSERT( !set.count( i ) );
            }

            for ( int i = 1; i < size; ++i ) {
                set.insert( i );
                ASSERT( set.count( i ) );
                ASSERT( !set.count( i + 1 ) );
            }

            for ( int i = 1; i < size; ++i ) {
                ASSERT( set.count( i ) );
            }

            for ( int i = size; i < 2 * size; ++i ) {
                ASSERT( !set.count( i ) );
            }
        }
    };

    template< template< typename, typename, int > class HS, typename V = int >
    struct parallel
    {

        using hashset = HS< V, brq::impl::quick, 24 >;

        struct Insert
        {
            hashset set;
            int from, to;
            bool overlap;

            void main() {
                for ( int i = from; i < to; ++i ) {
                    set.insert( i );
                    ASSERT( !set.insert( i ).isnew() );
                    if ( !overlap && i < to - 1 )
                        ASSERT( !set.count( i + 1 ) );
                }
            }
        };

        TEST(insert) {
            Insert a;
            a.from = 1;
            a.to = size;
            a.overlap = false;
            a.main();
            for ( int i = 1; i < size; ++i )
                ASSERT( a.set.count( i ) );
        }

        static hashset _par( int f1, int t1, int f2, int t2 )
        {
            brick::shmem::Thread< Insert > a, b( a );

            a.from = f1;
            a.to = t1;
            b.from = f2;
            b.to = t2;
            a.overlap = b.overlap = (t1 > f2);

            a.start();
            b.start();
            a.join();
            b.join();
            return a.set;
        }

        static hashset _multi( std::size_t count, int from, int to )
        {
            brick::shmem::ThreadSet< Insert > arr;
            arr.resize( count );

            for ( std::size_t i = 0; i < count; ++i )
            {
                arr[ i ].from = from;
                arr[ i ].to = to;
                arr[ i ].overlap = true;
            }

            arr.start();
            arr.join();

            return arr[ 0 ].set;
        }

        TEST(multi)
        {
            auto set = _multi( 10, 1, size );

            for  ( int i = 1; i < size; ++i )
                ASSERT( set.count( i ) );

            int count = 0;
            std::set< int > s;
            for ( size_t i = 0; i != set.capacity(); ++i ) {
                if ( set.valueAt( i ) ) {
                    if ( s.find( set.valueAt( i ) ) == s.end() )
                        s.insert( set.valueAt( i ) );
                    ++count;
                }
            }
            ASSERT_EQ( count, size - 1 );
        }

        TEST(stress)
        {
            auto s = _par( 1, size / 2, size / 4, size );

            for ( int i = 1; i < size; ++i )
                ASSERT( s.count( i ) );
        }

        TEST(empty)
        {
            hashset set;

            for ( int i = 1; i < size; ++i )
                ASSERT( !set.count( i ) );
        }

        TEST(set)
        {
            auto set = _par( 1, size / 2, size / 2, size );

            for ( int i = 1; i < size; ++i )
                ASSERT_EQ( i, i * set.count( i ) );

            for ( int i = size; i < size * 2; ++i )
                ASSERT( !set.count( i ) );
        }
    };

    /* instantiate the testcases */
    template struct sequential< brq::hash_set >;
    template struct sequential< brq::concurrent_hash_set >;
    template struct parallel< brq::concurrent_hash_set >;

    template struct sequential< brq::hash_set, int64_t >;
    template struct sequential< brq::concurrent_hash_set, int64_t >;
    template struct parallel< brq::concurrent_hash_set, int64_t >;

    template struct sequential< brq::hash_set, big >;
    template struct sequential< brq::concurrent_hash_set, big >;
    template struct parallel< brq::concurrent_hash_set, big >;

}

#ifdef BRICK_BENCHMARK_REG

#include <brick-hlist.h>
#include <brick-benchmark.h>
#include <unordered_set>

#ifdef BRICKS_HAVE_TBB
#include <tbb/concurrent_hash_map.h>
#include <tbb/concurrent_unordered_set.h>
#endif

namespace brick {
namespace b_hashset {

template< typename HS >
struct RandomThread : brick::shmem::Thread {
    HS *_set;
    typename HS::ThreadData td;
    int count, id;
    std::mt19937 rand;
    std::uniform_int_distribution<> dist;
    bool insert;
    int max;

    RandomThread() : insert( true ) {}

    void main() {
        rand.seed( id );
        auto set = _set->withTD( td );
        for ( int i = 0; i < count; ++i ) {
            int v = dist( rand );
            if ( max < std::numeric_limits< int >::max() ) {
                v = v % max;
                v = v * v + v + 41; /* spread out the values */
            }
            if ( insert )
                set.insert( v );
            else
                set.count( v );
        }
    };
};

namespace {

Axis axis_items( int min = 16, int max = 16 * 1024 ) {
    Axis a;
    a.type = Axis::Quantitative;
    a.name = "items";
    a.log = true;
    a.step = sqrt(sqrt(2));
    a.normalize = Axis::Div;
    a.unit = "k";
    a.unit_div =    1000;
    a.min = min * 1000;
    a.max = max * 1000;
    return a;
}

Axis axis_threads( int max = 16 ) {
    Axis a;
    a.type = Axis::Quantitative;
    a.name = "threads";
    a.normalize = Axis::Mult;
    a.unit = "";
    a.min = 1;
    a.max = max;
    a.step = 1;
    return a;
}

Axis axis_reserve( int max = 200, int step = 50 )
{
    Axis a;
    a.type = Axis::Quantitative;
    a.name = "reserve";
    a.unit = "%";
    a.min = 0;
    a.max = max;
    a.step = step;
    return a;
}

Axis axis_types( int count )
{
    Axis a;
    a.type = Axis::Qualitative;
    a.name = "type";
    a.unit = "";
    a.min = 0;
    a.max = count - 1;
    a.step = 1;
    return a;
}

}

template< typename T > struct TN {};
template< typename > struct _void { typedef void T; };

template< typename Ts >
struct Run : BenchmarkGroup
{
    template< typename, int Id >
    std::string render( int, hlist::not_preferred ) { return ""; }

    template< typename Tss = Ts, int Id = 0, typename = typename Tss::Head >
    std::string render( int id, hlist::preferred = hlist::preferred() )
    {
        if ( id == Id )
            return TN< typename Tss::Head >::n();
        return render< typename Tss::Tail, Id + 1 >( id, hlist::preferred() );
    }

    std::string describe() {
        std::string s;
        for ( int i = 0; i < int( Ts::length ); ++i )
            s += " type:" + render( i );
        return std::string( s, 1, s.size() );
    }

    template< template< typename > class, typename Self, int, typename, typename... Args >
    static void run( Self *, hlist::not_preferred, Args... ) {
        UNREACHABLE( "brick::b_hashset::Run fell off the cliff" );
    }

    template< template< typename > class RI, typename Self, int id,
              typename Tss, typename... Args >
    static auto run( Self *self, hlist::preferred, Args... args )
        -> typename _void< typename Tss::Head >::T
    {
        if ( self->type() == id ) {
            RI< typename Tss::Head > x( self, args... );
            self->reset(); // do not count the constructor
            x( self );
        } else
            run< RI, Self, id + 1, typename Tss::Tail, Args... >( self, hlist::preferred(), args... );
    }

    template< template< typename > class RI, typename Self, typename... Args >
    static void run( Self *self, Args... args ) {
        run< RI, Self, 0, Ts, Args... >( self, hlist::preferred(), args... );
    }

    int type() { return 0; } // default
};

template< int _threads, typename T >
struct ItemsVsReserve : Run< hlist::TypeList< T > >
{
    ItemsVsReserve() {
        this->x = axis_items();
        this->y = axis_reserve();
    }

    std::string fixed() {
        std::stringstream s;
        s << "threads:" << _threads;
        return s.str();
    }

    int threads() { return _threads; }
    int items() { return this->p; }
    double reserve() { return this->q / 100; }
    double normal() { return _threads; }
};

template< int _max_threads, int _reserve, typename T >
struct ItemsVsThreads : Run< hlist::TypeList< T > >
{
    ItemsVsThreads() {
        this->x = axis_items();
        this->y = axis_threads( _max_threads );
    }

    std::string fixed() {
        std::stringstream s;
        s << "reserve:" << _reserve;
        return s.str();
    }

    int threads() { return this->q; }
    int items() { return this->p; }
    double reserve() { return _reserve / 100.0; }
};

template< int _items, typename T >
struct ThreadsVsReserve : Run< hlist::TypeList< T > >
{
    ThreadsVsReserve() {
        this->x = axis_threads();
        this->y = axis_reserve();
    }

    std::string fixed() {
        std::stringstream s;
        s << "items:" << _items << "k";
        return s.str();
    }

    int threads() { return this->p; }
    int reserve() { return this->q; }
    int items() { return _items * 1000; }
};

template< int _threads, int _reserve, typename... Ts >
struct ItemsVsTypes : Run< hlist::TypeList< Ts... > >
{
    ItemsVsTypes() {
        this->x = axis_items();
        this->y = axis_types( sizeof...( Ts ) );
        this->y._render = [this]( int i ) {
            return this->render( i );
        };
    }

    std::string fixed() {
        std::stringstream s;
        s << "threads:" << _threads << " reserve:" << _reserve;
        return s.str();
    }

    int threads() { return _threads; }
    double reserve() { return _reserve / 100.0; }
    int items() { return this->p; }
    int type() { return this->q; }
    double normal() { return _threads; }
};

template< int _items, int _reserve, int _threads, typename... Ts >
struct ThreadsVsTypes : Run< hlist::TypeList< Ts... > >
{
    ThreadsVsTypes() {
        this->x = axis_threads( _threads );
        this->y = axis_types( sizeof...( Ts ) );
        this->y._render = [this]( int i ) {
            return this->render( i );
        };
    }

    std::string fixed() {
        std::stringstream s;
        s << "items:" << _items << "k reserve:" << _reserve;
        return s.str();
    }

    int threads() { return this->p; }
    double reserve() { return _reserve / 100.0; }
    int items() { return _items * 1000; }
    int type() { return this->q; }
    double normal() { return 1.0 / items(); }
};

template< typename T >
struct RandomInsert {
    bool insert;
    int max;
    using HS = typename T::template HashTable< int >;
    HS t;

    template< typename BG >
    RandomInsert( BG *bg, int max = std::numeric_limits< int >::max() )
        : insert( true ), max( max )
    {
        if ( bg->reserve() > 0 )
            t.reserve( bg->items() * bg->reserve() );
    }

    template< typename BG >
    void operator()( BG *bg )
    {
        RandomThread< HS > *ri = new RandomThread< HS >[ bg->threads() ];

        for ( int i = 0; i < bg->threads(); ++i ) {
            ri[i].id = i;
            ri[i].insert = insert;
            ri[i].max = max;
            ri[i].count = bg->items() / bg->threads();
            ri[i]._set = &t;
        }

        for ( int i = 0; i < bg->threads(); ++i )
            ri[i].start();
        for ( int i = 0; i < bg->threads(); ++i )
            ri[i].join();
    }
};

template< typename T >
struct RandomLookup : RandomInsert< T > {

    template< typename BG >
    RandomLookup( BG *bg, int ins_max, int look_max )
        : RandomInsert< T >( bg, ins_max )
    {
        (*this)( bg );
        this->max = look_max;
        this->insert = false;
    }
};

template< typename Param >
struct Bench : Param
{
    std::string describe() {
        return "category:hashset " + Param::describe() + " " +
            Param::fixed() + " " + this->describe_axes();
    }

    BENCHMARK(random_insert_1x) {
        this->template run< RandomInsert >( this );
    }

    BENCHMARK(random_insert_2x) {
        this->template run< RandomInsert >( this, this->items() / 2 );
    }

    BENCHMARK(random_insert_4x) {
        this->template run< RandomInsert >( this, this->items() / 4 );
    }

    BENCHMARK(random_lookup_100) {
        this->template run< RandomInsert >( this );
    }

    BENCHMARK(random_lookup_50) {
        this->template run< RandomLookup >(
            this, this->items() / 2, this->items() );
    }

    BENCHMARK(random_lookup_25) {
        this->template run< RandomLookup >(
            this, this->items() / 4, this->items() );
    }
};

template< template< typename > class C >
struct wrap_hashset {
    template< typename T > using HashTable = C< T >;
};

template< template< typename > class C >
struct wrap_set {
    template< typename T >
    struct HashTable {
        C< T > *t;
        struct ThreadData {};
        HashTable< T > withTD( ThreadData & ) { return *this; }
        void reserve( int s ) { t->rehash( s ); }
        void insert( T i ) { t->insert( i ); }
        int count( T i ) { return t->count( i ); }
        HashTable() : t( new C< T > ) {}
    };
};

struct empty {};

template< template< typename > class C >
struct wrap_map {
    template< typename T >
    struct HashTable : wrap_set< C >::template HashTable< T >
    {
        template< typename TD >
        HashTable< T > &withTD( TD & ) { return *this; }
        void insert( int v ) {
            this->t->insert( std::make_pair( v, empty() ) );
        }
    };
};

template< typename T >
using unordered_set = std::unordered_set< T >;

using A = wrap_set< unordered_set >;
using B = wrap_hashset< CS >;
using C = wrap_hashset< FS >;
using D = wrap_hashset< PS >;

template<> struct TN< A > { static const char *n() { return "std"; } };
template<> struct TN< B > { static const char *n() { return "scs"; } };
template<> struct TN< C > { static const char *n() { return "sfs"; } };
template<> struct TN< D > { static const char *n() { return "ccs"; } };
template<> struct TN< E > { static const char *n() { return "cfs"; } };

#define FOR_SEQ(M) M(A) M(B) M(C)
#define SEQ A, B, C

#ifdef BRICKS_HAVE_TBB
#define FOR_PAR(M) M(D) M(E) M(F) M(G)
#define PAR D, E, F, G

template< typename T > using cus = tbb::concurrent_unordered_set< T >;
template< typename T > using chm = tbb::concurrent_hash_map< T, empty >;

using F = wrap_set< cus >;
using G = wrap_map< chm >;

template<> struct TN< F > { static const char *n() { return "cus"; } };
template<> struct TN< G > { static const char *n() { return "chm"; } };

#else
#define FOR_PAR(M) M(D) M(E)
#define PAR D, E
#endif

#define TvT(N) \
    template struct Bench< ThreadsVsTypes< N, 50, 4, PAR > >;

TvT(1024)
TvT(16 * 1024)

#define IvTh_PAR(T) \
  template struct Bench< ItemsVsThreads< 4, 0, T > >;

template struct Bench< ItemsVsTypes< 1, 0, SEQ, PAR > >;
template struct Bench< ItemsVsTypes< 2, 0, PAR > >;
template struct Bench< ItemsVsTypes< 4, 0, PAR > >;

#define IvR_SEQ(T) \
  template struct Bench< ItemsVsReserve< 1, T > >;
#define IvR_PAR(T) \
  template struct Bench< ItemsVsReserve< 1, T > >; \
  template struct Bench< ItemsVsReserve< 2, T > >; \
  template struct Bench< ItemsVsReserve< 4, T > >;

FOR_PAR(IvTh_PAR)

FOR_SEQ(IvR_SEQ)
FOR_PAR(IvR_PAR)

#undef FOR_SEQ
#undef FOR_PAR
#undef SEQ
#undef PAR
#undef IvT_PAR
#undef IvR_SEQ
#undef IvR_PAR


}
}

#endif // benchmarks

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab ft=cpp
