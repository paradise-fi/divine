// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Utilities for printing SMT-LIBv2 formulas
 */

/*
 * (c) 2017 Vladimír Štill <xstill@fi.muni.cz>
 * (c) 2018 Petr Ročkai <code@fixp.eu>
 * (c) 2019 Henrich Lauko <xlauko@mail.muni.cz>
 */

/* Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE. */

#ifndef BRICK_SMT_H
#define BRICK_SMT_H

#include <brick-assert>
#include <brick-string>
#include <brick-data>

#include <memory>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <functional>
#include <unordered_map>
#include <unordered_set>

#if _LIBCPP_VERSION >= 4000 || __GLIBCXX__ >= 20170630
#include <string_view>
#else
#include <experimental/string_view>
namespace std { using experimental::string_view; }
#endif

namespace brick {
namespace smt {

using Format = std::function< void ( std::ostream & ) >;
struct Context;

enum class Op
{
    FirstUnary,
    Not = FirstUnary,
    BvNot,
    BvNegate,
    LastUnary = BvNegate,

    FirstCast,
	FPExt = FirstCast,
	FPTrunc,
	FPToSInt,
	FPToUInt,
	SIntToFP,
	UIntToFP,
    LastCast = UIntToFP,

    FirstBvBinary,
    And = FirstBvBinary,
    Or,
    Xor,
    Implies,

    Concat,

    BvAnd,
    BvOr,
    BvXor,
    BvAdd,
    BvSub,
    BvMul,
    BvUDiv,
    BvSDiv,
    BvURem,
    BvSRem,
    BvShl,
    BvLShr,
    BvAShr,

    // Icmp
    FirstICMP,
    Eq = FirstICMP,
    BvULE,
    BvULT,
    BvUGE,
    BvUGT,
    BvSLE,
    BvSLT,
    BvSGE,
    BvSGT,
    LastICMP = BvSGT,
    LastBvBinary = LastICMP,

    FirstFpBinary,
    FpAdd = FirstFpBinary,
    FpSub,
    FpMul,
    FpDiv,
    FpRem,

	// Fcmp
	FirstFCMP,
	FpFalse = FirstFCMP, // no comparison, always returns false
	FpOEQ,   // ordered and equal
	FpOGT,   // ordered and greater than
	FpOGE,   // ordered and greater than or equal
	FpOLT,   // ordered and less than
	FpOLE,   // ordered and less than or equal
	FpONE,   // ordered and not equal
	FpORD,   // ordered (no nans)
	FpUEQ,   // unordered or equal
	FpUGT,   // unordered or greater than
	FpUGE,   // unordered or greater than or equal
	FpULT,   // unordered or less than
	FpULE,   // unordered or less than or equal
	FpUNE,   // unordered or not equal
	FpUNO,   // unordered (either nans)
	FpTrue,  // no comparison, always returns true
	LastFCMP = FpTrue,
	LastFpBinary = LastFCMP,

    Extract,
};

inline std::string_view name( Op op )
{
    switch ( op )
    {
        case Op::Not: return "not";
        case Op::BvNot: return "bvnot";
        case Op::BvNegate: return "bvneg";

        case Op::Eq: return "=";
        case Op::And: return "and";
        case Op::Or: return "or";
        case Op::Xor: return "xor";
        case Op::Implies: return "=>";

        case Op::Concat: return "concat";

        case Op::BvAnd: return "bvand";
        case Op::BvOr: return "bvor";
        case Op::BvXor: return "bvxor";
        case Op::BvAdd: return "bvadd";
        case Op::BvSub: return "bvsub";
        case Op::BvMul: return "bvmul";
        case Op::BvUDiv: return "bvudiv";
        case Op::BvSDiv: return "bvsdiv";
        case Op::BvURem: return "bvurem";
        case Op::BvSRem: return "bvsrem";
        case Op::BvShl: return "bvshl";
        case Op::BvAShr: return "bvashr";
        case Op::BvLShr: return "bvlshr";

        case Op::FpAdd:  return "fp.add";
        case Op::FpSub:  return "fp.sub";
        case Op::FpMul:  return "fp.mul";
        case Op::FpDiv:  return "fp.div";
        case Op::FpRem:  return "fp.rem";

        case Op::BvULE: return "bvule";
        case Op::BvULT: return "bvult";
        case Op::BvUGE: return "bvuge";
        case Op::BvUGT: return "bvugt";
        case Op::BvSLE: return "bvsle";
        case Op::BvSLT: return "bvslt";
        case Op::BvSGE: return "bvsge";
        case Op::BvSGT: return "bvsgt";

        case Op::FpFalse:
            UNREACHABLE_F( "Unsupported operation" );
        case Op::FpOEQ: return "fp.eq";
        case Op::FpOGT: return "fp.gt";
        case Op::FpOGE: return "fp.geq";
        case Op::FpOLT: return "fp.lt";
        case Op::FpOLE: return "fp.leq";
        case Op::FpONE: return "distinct"; // TODO neq
        case Op::FpORD:
            UNREACHABLE_F( "Unsupported operation" );
        case Op::FpUEQ: return "fp.eq";
        case Op::FpUGT: return "fp.gt";
        case Op::FpUGE: return "fp.geq";
        case Op::FpULT: return "fp.lt";
        case Op::FpULE: return "fp.leq";
        case Op::FpUNE: return "distinct"; // TODO neq
        case Op::FpUNO:
            UNREACHABLE_F( "Unsupported operation" );
        case Op::FpTrue:
            UNREACHABLE_F( "Unsupported operation" );

        case Op::Extract: return "extract";
        default: UNREACHABLE_F( "unknown operation %d", int( op ) );
    }
}

template< typename T >
union ByteUnion
{
    using Byte = uint8_t;

    ByteUnion( T data ) : data( data ) {}

    T data;
    Byte bytes[ sizeof( T ) ];

    constexpr const Byte * begin() const noexcept { return bytes; }
    constexpr const Byte * end() const noexcept { return bytes + size(); }
    constexpr const std::size_t size() const { return sizeof( T ); };
};

template< typename Container >
struct RPN
{
    using Bitwidth = int8_t;
    using VarID = uint16_t;

    using size_type = typename Container::size_type;
    using iterator = typename Container::iterator;
    using const_iterator = typename Container::const_iterator;

    enum class Op : uint8_t
    {
        Invalid,

        VarI8, FisrtVar = VarI8,
        VarI16,
        VarI32,
        VarI64,
        VarFP32,
        VarFP64,
        VarFP80, LastVar = VarFP80,

        I1, FirstConstant = I1,
        I8,
        I16,
        I32,
        I64,
        FP32,
        FP64,
        FP80, LastConstant = FP80,

        FirstUnary,
        Not = FirstUnary,
        BvNot,
        LastUnary = BvNot,

        FirstCast,
        SExt = FirstCast,
        ZExt,
        Trunc,
        FPExt,
        FPTrunc,
        FPToSInt,
        FPToUInt,
        SIntToFP,
        UIntToFP,
        LastCast = UIntToFP,

        FirstBinary,
        And = FirstBinary,
        Or,
        Xor,
        Add,
        Sub,
        Mul,
        UDiv,
        SDiv,
        URem,
        SRem,
        Shl,
        LShr,
        AShr,

        // Icmp
        FirstICMP,
        EQ = FirstICMP,
        NE,
        ULE,
        ULT,
        UGE,
        UGT,
        SLE,
        SLT,
        SGE,
        SGT,
        LastICMP = SGT,
        LastBinary = LastICMP,

        Constraint,

        Extract,
    };

    template< typename T >
    struct Constant
    {
        Bitwidth bw;
        T value;
    } __attribute__(( packed, aligned(1) ));

    static_assert( sizeof( Constant< uint8_t > ) == 2 );
    static_assert( sizeof( Constant< uint32_t > ) == 5 );

    struct Variable
    {
        Op op;
        VarID id;
    } __attribute__(( packed, aligned(1) ));

    static_assert( sizeof( Variable ) == 3 );

    RPN( Variable var ) : RPN( ByteUnion< Variable >( var ) ) {}

    template< typename T >
    RPN( Constant< T > con ) : RPN( ByteUnion< Constant< T > >( con ) ) {}

    template< typename T >
    RPN( ByteUnion< T > bytes ) noexcept
        : _data( bytes.size(), bytes.begin(), bytes.end() )
    {}

    RPN( Container cont ) noexcept : _data( cont ) {}

    RPN( const RPN& ) = default;
    RPN( RPN&& ) = default;

    RPN& operator=( const RPN& ) = default;
    RPN& operator=( RPN& ) = default;

    template< typename T >
    static inline constexpr Op ivar() noexcept
    {
        if constexpr ( sizeof( T ) == 1 )
            return Op::VarI8;
        if constexpr ( sizeof( T ) == 2 )
            return Op::VarI16;
        if constexpr ( sizeof( T ) == 4 )
            return Op::VarI32;
        if constexpr ( sizeof( T ) == 8 )
            return Op::VarI64;
    }

    template< typename T >
    static inline constexpr Op fpvar() noexcept
    {
        if constexpr ( sizeof( T ) == 4 )
            return Op::VarFP32;
        if constexpr ( sizeof( T ) == 8 )
            return Op::VarFP64;
        if constexpr ( sizeof( T ) == 10 )
            return Op::VarFP80;
    }

    template< typename T >
    static inline constexpr Op var() noexcept
    {
        if constexpr ( std::is_integral_v< T > )
            return ivar< T >();
        if constexpr ( std::is_floating_point_v< T > )
            return fpvar< T >();
    }

    static inline constexpr bool is_variable( Op op ) noexcept
    {
        return Op::FisrtVar <= op && op <= Op::LastVar;
    }

    static inline constexpr bool is_constant( Op op ) noexcept
    {
        return Op::FirstConstant <= op && op <= Op::LastConstant;
    }

    static inline constexpr bool is_unary( Op op ) noexcept
    {
        return Op::FirstUnary <= op && op <= Op::LastUnary;
    }

    static inline constexpr bool is_cast( Op op ) noexcept
    {
        return Op::FirstCast <= op && op <= Op::LastCast;
    }

    static inline constexpr bool is_binary( Op op ) noexcept
    {
        return Op::FirstBinary <= op && op <= Op::LastBinary;
    }

    constexpr Op op() const noexcept { return static_cast< Op >( _data.back() ); }

    constexpr Op operand() const noexcept { return static_cast< Op >( _data.front() ); }

    constexpr bool is_variable() const noexcept { return is_variable( operand() ); }
    constexpr bool is_constant() const noexcept
    {
        return static_cast< Bitwidth >( operand() ) < 0; // bitwidths are in negative range
    }
    constexpr bool is_unary() const noexcept { return is_unary( op() ); }
    constexpr bool is_binary() const noexcept { return is_binary( op() ); }
    constexpr bool is_cast() const noexcept { return is_cast( op() ); }
    constexpr bool is_constraint() const noexcept { return op() == Op::Constraint; }


    constexpr Bitwidth bitwidth() const noexcept
    {
        assert( !is_variable() ); // TODO bitwidth for variables
        return -static_cast< Bitwidth >( operand() );
    }

    template< typename T >
    constexpr T extract( size_t from = 0 ) const noexcept
    {
        auto it = std::next( _data.begin(), from );
        return *reinterpret_cast< T * >( const_cast< uint8_t * >( it ) );
    }

    constexpr VarID id() const noexcept
    {
        assert( is_variable() );
        constexpr auto offset = 1;
        return extract< VarID >( offset );
    }

    template< typename T >
    constexpr T extract_constant() const noexcept
    {
        assert( is_constant() );
        auto bw = bitwidth();
        constexpr auto offset = 1;
        return extract< T >( offset );
    }

    size_type size() const noexcept { return _data.size(); }

    iterator begin() noexcept { return _data.begin(); }
    const_iterator begin() const noexcept { return _data.begin(); }

    iterator end() noexcept { return _data.end(); }
    const_iterator end() const noexcept { return _data.end(); }

    constexpr void apply( Op op ) noexcept
    {
        _data.push_back( static_cast< uint8_t >( op ) );
    }

    constexpr void extend( const RPN& other ) noexcept
    {
        _data.append( other.size(), other.begin(), other.end() );
    }

private:
    Container _data;
};

struct Node
{
    enum class Type {
        Bool,
        Int,
        Float
    };

    Format _fmt;
    int bw = 0;
    Type type;

    Node( int bw, Type type, Format &&fmt ) :
        _fmt( std::move( fmt ) ), bw( bw ), type( type )
    {}

    Node( int bw, Type type, std::string str ) :
        _fmt( [=]( std::ostream &o ) { o << str; } ), bw( bw ), type( type )
    {}

    inline bool is_bool() { return type == Type::Bool; }
    inline bool is_bv() { return type == Type::Int; }
    inline bool is_float() { return type == Type::Float; }
};

static inline std::ostream &operator<<( std::ostream &o, const Node &n )
{
    n._fmt( o );
    return o;
}

inline std::string to_string( const Node &p )
{
    std::stringstream ss;
    ss << p;
    return ss.str();
}

enum class RoundingMode {
	RNE,	// round nearest ties to even
	RNA,	// round nearest ties to away
	RTP,	// round toward positive
	RTN,	// round toward negative
	RTZ	    // round toward zero
};

inline std::string to_string( RoundingMode mode )
{
	switch ( mode ) {
		case RoundingMode::RNE: return "RNE";
		case RoundingMode::RNA: return "RNA";
		case RoundingMode::RTP: return "RTP";
		case RoundingMode::RTN: return "RTN";
		case RoundingMode::RTZ: return "RTZ";
		default: UNREACHABLE_F( "Unknown rounding mode." );
	};
}

static inline std::ostream &operator<<( std::ostream &o, RoundingMode mode )
{
	o << to_string( mode );
	return o;
}

template< size_t bitwidth >
std::string to_fp();

template<>
inline std::string to_fp< 16 >() { return "(_ to_fp 5 11)"; }

template<>
inline std::string to_fp< 32 >() { return "(_ to_fp 8 24)"; }

template<>
inline std::string to_fp< 64 >() { return "(_ to_fp 11 53)"; }

inline std::string to_fp( size_t bw )
{
    switch ( bw )
    {
        case 16: return to_fp< 16 >();
        case 32: return to_fp< 32 >();
        case 64: return to_fp< 64 >();
        default: UNREACHABLE( "Unsupported bitwidth." );
    }
}


struct Context
{
    std::unordered_set< std::string > def_set;
    std::vector< std::pair< std::string, Node > > defs;
    std::unordered_map< std::string, Node > vars;

    void clear() { def_set.clear(); defs.clear(); vars.clear(); }

    Node define( std::string name, Node def )
    {
        ASSERT( !name.empty() );
        ASSERT( !def_set.count( name ) );
        def_set.insert( name );
        defs.emplace_back( name, def );
        return Node( def.bw, def.type, name );
    }

    Node variable( Node node, std::string name )
    {
        if ( vars.count( name ) )
            ASSERT_EQ( to_string( node ), to_string( vars.find( name )->second ) );
        else
            vars.emplace( name, node );
        return Node( node.bw, node.type, name );
    }

    Node symbol( int bw, Node::Type type, std::string name ) {
        return Node( bw, type, name );
    }

    Node bitvec( int, data::SmallVector< uint64_t > data );
    Node boolT() { return Node( 1, Node::Type::Bool, "Bool" ); }
    Node bitvecT( int bitwidth )
    {
        ASSERT_LEQ( 0, bitwidth );
        return Node( bitwidth, Node::Type::Int, "(_ BitVec " + std::to_string( bitwidth ) + ")" );
    }

    Node floatT( int bitwidth )
    {
        ASSERT_LEQ( 0, bitwidth );
        return Node( bitwidth, Node::Type::Float, "(Float" + std::to_string( bitwidth ) + ")" );
    }

    Node bitvec( int bw, uint64_t val )
    {
        return bitvec( bw, brick::data::SmallVector< uint64_t >{ val } );
    }

    template< typename Int, typename =
            std::enable_if_t< std::is_integral< Int >::value && (sizeof( Int ) <= sizeof( uint64_t )) > >
    Node bitvec( Int i )
    {
        return bitvec( sizeof( Int ) * 8, data::SmallVector< uint64_t >{ uint64_t( i ) } );
    }

    Node floatv( int bw, double val, RoundingMode mode = RoundingMode::RNE );

    void print( std::ostream &o, Node n, bool exq = true )
    {
        auto bind = [&]( std::string type, auto &vec, auto next )
        {
            for ( auto s : vec )
                o << std::endl << "    (" << type << " ((" << s.first << " " << s.second << ")) ";
            next();
            for ( unsigned i = 0; i < vec.size(); ++i )
                o << ")";
        };

        auto let = [&]{ bind( "let", defs, [&]{ o << n; } ); };
        if ( exq )
            bind( "exists", vars, let );
        else
            let();
    }

    void query( std::ostream &o, Node n )
    {
        for ( auto v : vars )
            o << "(declare-fun " << v.first << " () " << v.second << ")" << std::endl;
        o << "(assert ";
        print( o, n, false );
        o << ")" << std::endl << "(check-sat)";
    }

    std::string print( Node n, bool exq = true )
    {
        std::stringstream s;
        print( s, n, exq );
        return s.str();
    }

    std::string query( Node n )
    {
        std::stringstream s;
        query( s, n );
        return s.str();
    }

    using Vector = brick::data::SmallVector< Node, 2 >;

    bool is_cmp( Op op )
    {
        return ( op >= Op::FirstICMP && op <= Op::LastICMP ) ||
               ( op >= Op::FirstFCMP && op <= Op::LastFCMP );
    }

    bool is_rounding_mode_required( Op op )
    {
        return op == Op::FpAdd || op == Op::FpSub || op == Op::FpMul || op == Op::FpDiv;
    }

    Node expr( int bw, Op op, const Vector &args, std::optional< RoundingMode > mode )
    {
        auto fmt = [=]( std::ostream &o )
        {
            o << "(" << name( op );

            if ( is_rounding_mode_required( op ) )
            {
                ASSERT( mode.has_value() );
                o << " " << to_string( mode.value() );
            }

            for ( auto &a : args )
                o << " " << a;
            o << ")";
        };
        auto type = is_cmp( op ) ? Node::Type::Bool : args[ 0 ].type;
        return Node( bw, type, fmt );
    }

    Node expr( int bw, Op op, const Vector &args )
    {
        return expr( bw, op, args, std::nullopt );
    }


    template< Op op >
    Node unop( int bw, Node arg )
    {
        static_assert( op >= Op::FirstUnary && op <= Op::LastUnary, "op is not an unary operation" );
        return expr( bw, op, { arg } );
    }

    template< Op op >
    Node binop( int bw, Node a, Node b )
    {
        static_assert( op >= Op::FirstBvBinary && op <= Op::LastBvBinary,
                       "op is not a bitvector binary operation" );
        ASSERT( a.type == b.type );
        return expr( bw, op, { a, b } );
    }

    template< Op op >
    Node fpbinop( int bw, Node a, Node b )
    {
        static_assert( op >= Op::FirstFpBinary && op <= Op::LastFpBinary,
                       "op is not a floating point binary operation" );
        ASSERT( a.type == b.type );
        return expr( bw, op, { a, b }, RoundingMode::RNE );
    }

    Node extract( int highest, int lowest, Node arg )
    {
        ASSERT_LEQ( lowest, highest );
        auto f = [=]( std::ostream &o )
        {
            o << "((_ extract " << std::dec << highest << " " << lowest << ") " << arg << ")";
        };
        return Node( 1 + highest - lowest, Node::Type::Int, f );
    };

    Node ite( Node cond, Node t, Node f )
    {
        ASSERT_EQ( t.bw, f.bw );
        ASSERT( t.type == f.type );
        auto fmt = [=]( std::ostream &o ) { o << "(ite " << cond << " " << t << " " << f << ")"; };
        return Node( t.bw, t.type, fmt );
    }

    template< Op op > Node cast( int bw, const Node & arg );
};

namespace {

inline Node fp_to_fp_cast( int bw, const Node & arg )
{
    const RoundingMode mode = RoundingMode::RNE;
    auto fmt = [=]( std::ostream &o )
    {
        o << "(" << to_fp( bw ) << " " << to_string( mode ) << " " << arg << " )";
    };
    return Node( bw, Node::Type::Float, fmt );
}

} // anonymous namespace

template<>
inline Node Context::cast< Op::FPExt >( int bw, const Node & arg )
{
    return fp_to_fp_cast( bw, arg );
}

template<>
inline Node Context::cast< Op::FPTrunc >( int bw, const Node & arg )
{
    return fp_to_fp_cast( bw, arg );
}

template<>
inline Node Context::cast< Op::FPToSInt >( int, const Node & )
{
    NOT_IMPLEMENTED();
}

template<>
inline Node Context::cast< Op::FPToUInt >( int, const Node & )
{
    NOT_IMPLEMENTED();
}

template<>
inline Node Context::cast< Op::SIntToFP >( int, const Node & )
{
    NOT_IMPLEMENTED();
}

template<>
inline Node Context::cast< Op::UIntToFP >( int, const Node & )
{
    NOT_IMPLEMENTED();
}

inline static uint64_t u64mask( int bitwidth )
{
    if ( bitwidth >= 64 )
        return ~uint64_t( 0 );
    return (uint64_t( 1 ) << bitwidth) - 1;
}

namespace {

inline std::stringstream to_bitvecor( int bitwidth, brick::data::SmallVector< uint64_t > data ) {
    int bw = bitwidth;
    int i = 0;

    while ( bw > 0 && i < int( data.size() ) )
    {
        data[ i ] &= u64mask( bw );
        bw -= 64;
        ++i;
    }

    while ( i < int( data.size() ) )
        data.pop_back();
    while ( int( data.size() ) < (bitwidth + 63) / 64 )
        data.push_back( 0 );

    std::stringstream o;

    if ( bitwidth % 4 == 0 )
    {
        o << "#x" << std::hex;
        // data are little endian
        for ( int i = data.size() - 1; i >= 0; --i )
            o << std::setfill( '0' ) << std::setw( std::min( bitwidth - i * 64, 64 ) / 4 ) << data[i];
    }
    else
    {
        o << "#b";
        for ( int i = data.size() - 1; i >= 0; --i ) {
            for ( int j = std::min( bitwidth - 1 - i * 64, 63 ); j >= 0; --j )
                if ( data[i] & (uint64_t( 1 ) << j) )
                    o << '1';
                else
                    o << '0';
        }
    }

    return o;
}

} // anonymous namespace

inline Node Context::floatv( int bitwidth, double val, RoundingMode mode )
{
	static_assert( sizeof( double ) == sizeof( uint64_t ) );
    return Node( bitwidth, Node::Type::Float,
        "(" + to_fp( bitwidth ) + " " + to_string( mode ) + " " + std::to_string( val ) + " )"
    );
}

inline Node Context::bitvec( int bitwidth, brick::data::SmallVector< uint64_t > data )
{
    auto o = to_bitvecor( bitwidth, data );
    return Node( bitwidth, Node::Type::Int, o.str() );
}

} // namespace smt

namespace t_smt {
using namespace brick::smt;

/*
struct StringTest
{
    TEST(basic)
    {
        ASSERT_EQ( R"("a")", to_string( smt::string( "a" ) ) );
        std::string b( "b" );
        ASSERT_EQ( R"("b")", to_string( smt::string( b ) ) );
    }

    TEST(escape)
    {
        ASSERT_EQ( R"("a\\b\"c")", to_string( smt::string( R"(a\b"c)" ) ) );
        ASSERT_EQ( R"("a\\\"c")", to_string( smt::string( R"(a\"c)" ) ) );
    }
};
*/

struct BVecTest
{
    TEST(string)
    {
        Context ctx;

        auto a = ctx.bitvec( 42 );
        ASSERT_EQ( "#x0000002a", to_string( a ) );

        auto b = ctx.bitvec( uint64_t( 42 ) );
        ASSERT_EQ( "#x000000000000002a", to_string( b ) );

        auto c = ctx.bitvec( 4, 0xff );
        ASSERT_EQ( "#xf", to_string( c ) );

        brick::data::SmallVector< uint64_t > data = { ~uint64_t( 0 ), ~uint64_t( 0 ) };
        auto d = ctx.bitvec( 96, data );
        ASSERT_EQ( "#x" + std::string( 24, 'f' ), to_string( d ) );

        auto e = ctx.bitvec( 256, data );
        ASSERT_EQ( "#x" + std::string( 32, '0' ) + std::string( 32, 'f' ), to_string( e ) );

        auto f = ctx.bitvec( 96, 42 );
        ASSERT_EQ( "#x" + std::string( 22, '0' ) + "2a", to_string( f ) );

        auto g = ctx.bitvec( 16, data );
        ASSERT_EQ( "#xffff", to_string( g ) );

        auto h = ctx.bitvec( 7, data );
        ASSERT_EQ( "#b1111111", to_string( h ) );

        auto i = ctx.bitvec( 7, 0x29 );
        ASSERT_EQ( "#b0101001", to_string( i ) );

        auto j = ctx.bitvec( 67, { (uint64_t( 1 ) << 63) | 1, 0x5 } );
        ASSERT_EQ( "#b1011" + std::string( 62, '0' ) + "1", to_string( j ) );

        auto k = ctx.bitvec( 67, { (uint64_t( 1 ) << 33) | 1, 0x5 } );
        ASSERT_EQ( "#b101" + std::string( 30, '0' ) + "1" + std::string( 32, '0' ) + "1",
                   to_string( k ) );
    }
};

struct ExtractTest
{
    TEST(print)
    {
        Context ctx;

        ASSERT_EQ( "((_ extract 32 0) #x000000000000002a)",
                   to_string( ctx.extract( 32, 0, ctx.bitvec( 42ull ) ) ) );
        ASSERT_EQ( "((_ extract 15 15) (concat #xff #xff))",
                   to_string( ctx.extract( 15, 15,
                                           ctx.binop< Op::Concat >( 16,
                                                                    ctx.bitvec( 8, 0xff ),
                                                                    ctx.bitvec( 8, 0xff ) ) ) ) );
    }
};

struct CombinationTest
{
    TEST(simple)
    {
        Context ctx;

        ASSERT_EQ( to_string( ctx.binop< Op::BvAdd >( 32, ctx.bitvec( 42 ), ctx.bitvec( 32 ) ) ),
                   "(bvadd #x0000002a #x00000020)" );
        ASSERT_EQ( to_string( ctx.binop< Op::BvAnd >( 32, ctx.symbol( 32, Node::Type::Int, "a" )
                                                                        , ctx.bitvec( 3, 5 ) ) ),
                   "(bvand a #b101)" );
        ASSERT_EQ( to_string(
                       ctx.binop< Op::BvSLE >(
                           16, ctx.extract( 32, 16, ctx.symbol( 32, Node::Type::Int, "a" ) ),
                           ctx.unop< Op::BvNegate >( 16, ctx.bitvec( short( 42 ) ) ) ) ),
                   "(bvsle ((_ extract 32 16) a) (bvneg #x002a))" );
    }
/*
    TEST(constants)
    {
        ASSERT_EQ( to_string( defineFun( "a", bitvecT( 32 ), bitvec( 42 ) ) ),
                   "(define-fun a () (_ BitVec 32) #x0000002a)" );
        ASSERT_EQ( to_string( declareConst( "a", bitvecT( 32 ) ) ),
                   "(declare-const a (_ BitVec 32))" );
        ASSERT_EQ( to_string( defineFun( "b", bitvecT( 32 ),
                                  binop< Op::BvAnd >( 16, bitvec( short( 1 ) ),
                                                      bitvec( short( 2 ) ) ) ) ),
                   "(define-fun b () (_ BitVec 32) (bvand #x0001 #x0002))" );
    }
*/
};

} // namespace t_smt
} // namespace brick

#endif

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab ft=cpp
